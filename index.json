[{"content":"Iterator Iterator is an object that can loop over iterable objects. We can use Iterator in for loops. A list is a well known Iterator.\nImplementaion An object can be a Iterator, if we implement two methods:\n __iter__ - returns the object itself. __next__ - returns the next values and raises StopIteration exception when all objects are looped.   Generator Generator functions allow you to declare a function that behaves like an iterator.\nImplementaion Method 1 A simple and easy way to create a Generator is to replace a return statement with a yield statement in a function.\nThe difference is that while a return statement terminates a function entirely, yield statement pauses the function saving all its states and later continues from there on successive calls.\nMethod 2 An object can be a Generator, if we implement __next__ method.\nNote: In the above method the yield statement internally generated the __iter__ and __next__ methods.\nMethod 3 Generator expressions provide an additional shortcut to build generators out of expressions similar to that of list comprehensions.\n Notes  Every generator is an iterator, but not vice versa.\n  ","permalink":"http://harish678.github.io/posts/iteratorgenerator/","summary":"Iterator Iterator is an object that can loop over iterable objects. We can use Iterator in for loops. A list is a well known Iterator.\nImplementaion An object can be a Iterator, if we implement two methods:\n __iter__ - returns the object itself. __next__ - returns the next values and raises StopIteration exception when all objects are looped.   Generator Generator functions allow you to declare a function that behaves like an iterator.","title":"Iterators and Generators"},{"content":"Introduction Before looking into Decorators, we need to know key points about Functions in Python.\n Functions are Objects. Means they can be referenced, passed as an argument, can be returned as well.  Decorators dynamically alter the functionality of a function, method, or class without having to directly use subclasses or change the source code of the function being decorated Implementaion Function as a Decorator Boilerplate Code:\nimport functools def decorator(func): @functools.wraps(func) def wrapper_decorator(*args, **kwargs): # Do something before value = func(*args, **kwargs) # Do something after return value return wrapper_decorator Now we will see an example, how much time it took for a function to execute.\nThere are two ways to call a decorator (Both ways are shown in the code below):\n By using @ symbol. By wrapping the decorator on to a function.  Class as a Decorator Recall in the 2nd method above we have called the decorator using test2 = timer(test2). If timer is a class, it needs to take func as an argument in its __init__() method. The logic has to be written in __call__() method.\nBoilerplate Code:\nclass Decorator: def __init__(self, func): self.func = func def __call__(self, *args, **kwargs): # Do something before result = self.func(*args, **kwargs) # Do something after return result Now we will see the same example as above using Class Decorator\nDecorators with Arguments  We can pass some arguments to the Decorator as well. For that we have to enclose the whole decorator boilerplate code inside another function.\nIn the example we will send num_times to decorator and the decorator will call the wrapper function that many times.\nMultiple Decorators on a function  We can call multiple decorators on a single function.\nNote:Order of the decorators is IMPORTANT.\nIn the below example @repeat will be called first and @timer later. If we reverse the order the execution of the decorator is reversed. We are using the same repeat and timer decorators define in above examples.\n","permalink":"http://harish678.github.io/posts/decorators/","summary":"Introduction Before looking into Decorators, we need to know key points about Functions in Python.\n Functions are Objects. Means they can be referenced, passed as an argument, can be returned as well.  Decorators dynamically alter the functionality of a function, method, or class without having to directly use subclasses or change the source code of the function being decorated Implementaion Function as a Decorator Boilerplate Code:\nimport functools def decorator(func): @functools.","title":"Decorators"},{"content":"Introduction Context managers allow you to allocate and release resources precisely when you want to. The most widely used example of context managers is the with statement.\nSuppose you have two related operations which you’d like to execute as a pair, with a block of code in between. Context managers allow you to do specifically that.\nImplementaion In the below example we will implement a program to open the file and read its contents using two methods.\nMethod 1 An object can be a Context Manager if we add __enter__ and __exit__ methods.\nMethod 2 Can create a Context Manager using @contextmanager decorator 1.\nThe function being decorated must return a generator-iterator when called.\nFootNotes   https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager \u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"http://harish678.github.io/posts/contextmanager/","summary":"Introduction Context managers allow you to allocate and release resources precisely when you want to. The most widely used example of context managers is the with statement.\nSuppose you have two related operations which you’d like to execute as a pair, with a block of code in between. Context managers allow you to do specifically that.\nImplementaion In the below example we will implement a program to open the file and read its contents using two methods.","title":"Context Manager"}]
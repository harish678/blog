[{"content":"Introduction A Metaclass means the class of a class. In Python Classes are objects, which are instances of some Class.\nAs can see below every Class in Python are instance of a class type.\nclass Example: pass \u0026gt;\u0026gt;\u0026gt; type(Example) \u0026lt;class \u0026#39;type\u0026#39;\u0026gt;  type is a MetaClass in Python which is responsible for classes creation.\n  Dynamic Class creation using type()   When type() is called with one argument, it returns the argument type.\n  When type() is called with 3 arguments, a class is created.\n Class name Tuple having base classes inherited by class Class dictionary populated with class methods and variables    # creating a base class class Base: def myfunc(self): print(\u0026#34;This is from Base!\u0026#34;) # Normal Way class Test(Base): x = 1 # Dynamic Way using type() Test = type(\u0026#39;Test\u0026#39;, (Base, ), dict(x=1))  Creating Custom Metaclass Let\u0026rsquo;s consider an example:\nclass Foo: pass \u0026gt;\u0026gt;\u0026gt; f = Foo() The expression Foo() creates a new instance of class Foo and the following occurs:\n  The __call__ method of Foo’s parent class is called. Since Foo is a standard new-style class, its parent class is the type metaclass, so type’s __call__ method is invoked.\n  That __call__ method in turn invokes the following:\n __new__ __init__    To create a Custom MetaClass, the class has to inherit type and overide __new__, __init__ methods.\n Notes  Metaclasses can be used when the classes needs to change dynamically. Metaclasses can be used when a decorator needs to be applied to every function in a class.  ","permalink":"http://harish678.github.io/posts/metaclass/","summary":"Introduction A Metaclass means the class of a class. In Python Classes are objects, which are instances of some Class.\nAs can see below every Class in Python are instance of a class type.\nclass Example: pass \u0026gt;\u0026gt;\u0026gt; type(Example) \u0026lt;class \u0026#39;type\u0026#39;\u0026gt;  type is a MetaClass in Python which is responsible for classes creation.\n  Dynamic Class creation using type()   When type() is called with one argument, it returns the argument type.","title":"Meta Classes"},{"content":"Iterator Iterator is an object that can loop over iterable objects. We can use Iterator in for loops. A list is a well known Iterator.\nImplementaion An object can be a Iterator, if we implement two methods:\n __iter__ - returns the object itself. __next__ - returns the next values and raises StopIteration exception when all objects are looped.   Generator Generator functions allow you to declare a function that behaves like an iterator.\nImplementaion Method 1 A simple and easy way to create a Generator is to replace a return statement with a yield statement in a function.\nThe difference is that while a return statement terminates a function entirely, yield statement pauses the function saving all its states and later continues from there on successive calls.\nMethod 2 An object can be a Generator, if we implement __next__ method.\nNote: In the above method the yield statement internally generated the __iter__ and __next__ methods.\nMethod 3 Generator expressions provide an additional shortcut to build generators out of expressions similar to that of list comprehensions.\n Notes  Every generator is an iterator, but not vice versa.\n  ","permalink":"http://harish678.github.io/posts/iteratorgenerator/","summary":"Iterator Iterator is an object that can loop over iterable objects. We can use Iterator in for loops. A list is a well known Iterator.\nImplementaion An object can be a Iterator, if we implement two methods:\n __iter__ - returns the object itself. __next__ - returns the next values and raises StopIteration exception when all objects are looped.   Generator Generator functions allow you to declare a function that behaves like an iterator.","title":"Iterators and Generators"},{"content":"Introduction Before looking into Decorators, we need to know key points about Functions in Python.\n Functions are Objects. Means they can be referenced, passed as an argument, can be returned as well.  Decorators dynamically alter the functionality of a function, method, or class without having to directly use subclasses or change the source code of the function being decorated Implementaion Function as a Decorator Boilerplate Code:\nimport functools def decorator(func): @functools.wraps(func) def wrapper_decorator(*args, **kwargs): # Do something before value = func(*args, **kwargs) # Do something after return value return wrapper_decorator Now we will see an example, how much time it took for a function to execute.\nThere are two ways to call a decorator (Both ways are shown in the code below):\n By using @ symbol. By wrapping the decorator on to a function.  Class as a Decorator Recall in the 2nd method above we have called the decorator using test2 = timer(test2). If timer is a class, it needs to take func as an argument in its __init__() method. The logic has to be written in __call__() method.\nBoilerplate Code:\nclass Decorator: def __init__(self, func): self.func = func def __call__(self, *args, **kwargs): # Do something before result = self.func(*args, **kwargs) # Do something after return result Now we will see the same example as above using Class Decorator\nDecorators with Arguments  We can pass some arguments to the Decorator as well. For that we have to enclose the whole decorator boilerplate code inside another function.\nIn the example we will send num_times to decorator and the decorator will call the wrapper function that many times.\nMultiple Decorators on a function  We can call multiple decorators on a single function.\nNote:Order of the decorators is IMPORTANT.\nIn the below example @repeat will be called first and @timer later. If we reverse the order the execution of the decorator is reversed. We are using the same repeat and timer decorators define in above examples.\n","permalink":"http://harish678.github.io/posts/decorators/","summary":"Introduction Before looking into Decorators, we need to know key points about Functions in Python.\n Functions are Objects. Means they can be referenced, passed as an argument, can be returned as well.  Decorators dynamically alter the functionality of a function, method, or class without having to directly use subclasses or change the source code of the function being decorated Implementaion Function as a Decorator Boilerplate Code:\nimport functools def decorator(func): @functools.","title":"Decorators"},{"content":"Introduction Context managers allow you to allocate and release resources precisely when you want to. The most widely used example of context managers is the with statement.\nSuppose you have two related operations which you’d like to execute as a pair, with a block of code in between. Context managers allow you to do specifically that.\nImplementaion In the below example we will implement a program to open the file and read its contents using two methods.\nMethod 1 An object can be a Context Manager if we add __enter__ and __exit__ methods.\nMethod 2 Can create a Context Manager using @contextmanager decorator 1.\nThe function being decorated must return a generator-iterator when called.\nFootNotes   https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager \u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"http://harish678.github.io/posts/contextmanager/","summary":"Introduction Context managers allow you to allocate and release resources precisely when you want to. The most widely used example of context managers is the with statement.\nSuppose you have two related operations which you’d like to execute as a pair, with a block of code in between. Context managers allow you to do specifically that.\nImplementaion In the below example we will implement a program to open the file and read its contents using two methods.","title":"Context Manager"}]